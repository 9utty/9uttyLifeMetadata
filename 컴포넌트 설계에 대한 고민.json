{
  "title": "컴포넌트 설계에 대한 고민",
  "createAt": "2024-10-01T11:57:00.000Z",
  "updateAt": "2024-10-09T12:52:00.000Z",
  "tags": "Frontend,Web,Component,NextJS",
  "content": "```yaml\ncleanUrl: \"/frontend/component-design-think\"\ntitle: \"컴포넌트 설계에 대한 고민\"\ndescription: \"프론트엔드 개발자인 이건학은 컴포넌트 설계에 대한 고민을 공유하며, 효율적인 개발과 유지보수를 위한 방법론을 설명하고, 폴더 구조와 각 컴포넌트/훅의 역할을 명확히 하여 재사용성과 가독성을 높이는 방안을 제시한다.\"\nogImage: \"https://opengraph.b-cdn.net/production/images/c75fa6d5-ce88-493d-89c1-57b7636d623c.png?token=ZQPb-u9y5Kec5UbWnfDtQMX6NHrbO3qZGAJEkjkWFj4&height=1200&width=1200&expires=33263845179\"\n```\n\n안녕하세요. 프론트엔드 2년차 주니어 개발자 이건학입니다.\n\n최근 회사에서 처음으로 담당하게 된 프로젝트의 초기 개발부터 배포, 운영, 유지보수까지 경험하면서 컴포넌트 설계에 대해 많은 고민을 하게 되었습니다.\n여러 시도 끝에 제가 현재 적용하고 있는 방법에 대해 공유드리고자 합니다.\n\n\n\n# 조회 페이지 컴포넌트 역할 분리 필요성\n\n---\n\n- 프로젝트 초기부터 빠르게 변화하는 게임 콘텐츠에 맞춰 개발하며 다양한 방법을 시도했습니다. 이 경험은 신속한 개발과 효율적인 유지보수를 위한 제 개발 스타일을 정립하는 데 큰 도움이 되었습니다. 주니어 개발자로서 이는 정말 귀중한 기회였습니다.\n- 1년 넘게 프로젝트를 개발하고 운영한 결과, 제 개발 스타일이 어느 정도 확립된 것 같습니다. 이는 단순히 개인적인 선호를 넘어, 프로덕트에 최적화된 컴포넌트 설계로 발전했습니다.\n\n\n# 폴더 구조 (예시)\n\n---\n\n```javascript\nitem\n\t├── index.tsx\n\t├── hooks\n\t│   ├── useItemForm.tsx\n\t│   ├── useItemHandle.tsx\n\t│   └── useItemQuery.tsx\n\t└── components\n\t\t\t├── itemList.tsx\n\t\t\t└── edit\n\t\t\t\t\t├── index.tsx\n\t\t\t\t\t├── hooks\n\t\t\t\t\t│   ├── useItemEditForm.tsx\n\t\t\t\t\t│   ├── useItemEditHandle.tsx\n\t\t\t\t\t│   └── ...\n\t\t\t\t\t└── components\n\t\t\t\t\t\t\t├── inputItemLevel.tsx\n\t\t\t\t\t\t\t└── inputItemAmount.tsx\n\t\t\t\t\t\t\t└── ...\n\n```\n\n\n\n# 폴더 구조의 설명과 컴포넌트 설계 설명(예시 코드)\n\n---\n\n### 1. index.tsx\n\n- 이 파일은 item 페이지의 메인 컴포넌트로, 전체 구조를 조합하고 다른 컴포넌트를 포함합니다.\n### 2. hooks\n\n- useItemForm.tsx\n- 컴포넌트에서 사용하는 상태를 관리하는 Hook입니다.\n```javascript\nexport default function useItemForm() {\n\tconst [itemList, setItemList] = useState<Item[] | null>(null);\n\tconst [isLoading, setIsLoading] = useState<boolean>(true);\n\n\treturn {\n\t\titemList,\n\t\t\tsetItemList,\n\t\t\tisLoading,\n\t\t\tsetIsLoading\n\t\t};\n\t}\n\n```\n\n- useItemQuery.tsx\n- Get, Post 등의 API 요청 로직을 처리하는 Hook입니다.\n```javascript\nexport type ItemQueryType = ReturnType<typeof useGetItemListQuery>\n\nexport type ItemQuery = {\n\t\trefetch: ItemQueryType['refetch']\n\t\tstatus: ItemQueryType['status']\n\t}\n\ntype Props = {\n\tsetIsLoading: React.Dispatch<React.SetStateAction<boolean>>\n\tsetItemList: React.Dispatch<React.SetStateAction<Item[] | null>>\n}\n\nexport default function useItemQuery({setIsLoading, setItemList}: Props): ItemQuery {\n\tconst {data: itemListData, status: itemListStats, isError: itemListDataError, refetch: itemListRefetch} = useGetItemListQuery()\n\n\tReact.useEffect(() => {\n\t\tif(itemListData && itemListStatus === 'fulfilled') {\n\t\t\tsetIsLoading(false)\n\t\t\tsetItemList(itemListData)\n\t\t} else if (itemListDataError) {\n\t\t\tsetIsLoading(false)\n\t\t\tsetItemList(null)\n\t\t}\n\t}, [itemListData, itemListStats, itemListDataError])\n\n\treturn {\n\t\tstatus: itemListStaus,\n\t\trefetch: itemListRefetch\n\t}\n}\n\n```\n\n- useItemHandle.tsx\n- 컴포넌트 내에서 사용되는 다양한 함수들을 모아둡니다.\n```javascript\ntype Props = {\n\tquery: ItemQuery\n\tsetIsLoading: setIsLoading: React.Dispatch<React.SetStateAction<boolean>>\n}\n\nexport default function useItemHandle({query, setIsLoading}) {\n\tconst handleRefresh = React.useCallback(() => {\n\t\tif(query.status !== 'uninitialized') {\n\t\t\tquery.refetch()\n\t\t\tsetIsLoading(true)\n\t\t}\n\t}, [query])\n\n\t/**\n\t페이지 마운트시 무조건 Data를 가져올 수 있게 하기 위한 코드\n\t*/\n\tReact.useEffect(() => {\n\t\thandleRefresh()\n\t},[])\n\n\treturn {\n\t\thandleRefresh\n\t}\n}\n\n\n```\n\n- 각 Hook은 특정한 역할을 명확히 하여 기능 추가 및 수정 시 필요한 부분만을 쉽게 수정할 수 있도록 구조화했습니다. 예를 들어, query에서 버그가 발생했다면 해당 부분만 수정하면 되므로 유지보수가 용이합니다.\n### 3. components/itemList.tsx\n\n- API에서 받아온 데이터를 렌더링하는 View 컴포넌트입니다.\n```javascript\ntype Props = {\n\taccountId: string\n\tserviceId: string\n\titemList: Item[]\n}\n\nexport default function ItemListViewComponent({accountId, serviceId, itemList}: Props) {\n\tconst local = useGetLocal()\n\n\tconst col = React.useMemo<MRT_ColumnDef<Item>[]>(() => [\n\t\t{\n\t\t\tid: 'itemId',\n\t\t\taccessorFn: row => `${row.itemId}`,\n\t\t\theader: local.localeString('COMMON_ITEM_ID'),\n\t\t},\n\t\t...\n\t], [])\n\n\treturn (\n\t\t<CustomDataGrid<Item>\n\t\t\tcol={col}\n\t\t\t\trow={itemList}\n\t\t\t/>\n\t)\n}\n\n```\n\n- ItemListViewComponent는 View에 집중하고, 데이터 Fetching과 분리하여 관심사를 명확히 함으로써, 다른 컴포넌트에서도 재사용 가능하도록 설계되었습니다.\n### 4. components/edit\n\n- Edit 컴포넌트들도 메인 구조와 유사하게 구성했습니다. 여기서는 Edit 작업 시 ItemList의 데이터 상태에 대해 'Stale'하다는 것을 알려줘야 합니다. 이는 REST API 요청 시 데이터의 최신성을 유지하기 위해 필요합니다.\n- RTK Query의 Tag 기능 활용: 'item' 태그를 사용해 mutation 호출 시 캐시된 query 데이터를 Stale로 표시합니다. 이로 인해 Edit 작업 후 데이터가 자동으로 리패칭됩니다. 이는 Next.js의 App Route에서의 풀 라우트 캐시 관리와 유사한 기능입니다.\n- 자동 데이터 리패칭: Tag를 적절히 구성하면 Edit 작업 시 데이터가 자동으로 업데이트되어 사용자에게 최신 정보를 제공합니다.\n(참고 문서: [RTK Query 자동 리패칭](https://redux-toolkit.js.org/rtk-query/usage/automated-refetching#cache-tags))\n- useItemEditHandle.tsx\n- 이 Hook에는 입력받은 데이터를 검증하고 query를 실행하는 함수들이 포함되어 있습니다.\n```javascript\ntype Props = {\n\tquery: ItemQuery\n\tform: ItemEditFormType\n}\n\nexport default function useItemEditHandle({query, form}) {\n\tconst {setValue, formState, watch} = form\n\n\tconst noti = useNotification()\n\n\tconst validationData = React.useCallback((reason: string): PostItemEditBody | null => {\n\t\tif(!!formState.errors.reason) {\n\t\t\tnoti('COMMON_VALIDATION_ERROR', false)\n\n\t\t\treturn null\n\t\t} else if (!!formState.errors.newLevel) {\n\t\t\tnoti('COMMON_VALIDATION_ERROR', false)\n\n\t\t\treturn null\n\t\t} else {\n\t\t\treturn {\n\t\t\t\titemId: form.watch('itemId'),\n\t\t\t\tnewLevel: form.watch('newLevel'),\n\t\t\t\treason: reason\n\t\t\t}\n\t\t}\n\t}, [])\n\n\tconst handleApprove = React.useCallback((reason: string) => {\n\t\tconst data = validationData(reason)\n\n\t\tif(data) {\n\t\t\tquery.postUpdateItemLevelTicket(data)\n\t\t}\n\t},[])\n\n\treturn {\n\t\thandleApprove\n\t}\n}\n\n```\n\n```plain text\n\t- 이 edit용 handle hook은 입력받은 데이터에 form.errors가 있는지 확인합니다. 정상적인 입력이 완료되면 query를 실행하는 함수를 포함하고 있습니다.\n\n```\n\n\n\n# 장점 설명\n\n---\n\n### 1. 모듈화 및 재사용성\n\n- 구조화된 Hook 설계: 각 Hook이 특정한 역할을 갖고 있어, `useItemForm`, `useItemQuery`, `useItemHandle` 등으로 나누어져 있습니다. 이로 인해 각 기능을 독립적으로 관리할 수 있으며, 필요한 Hook만 선택적으로 재사용할 수 있습니다. 예를 들어, 새로운 컴포넌트에서 `useItemQuery`만 가져와도 API 요청 로직을 쉽게 활용할 수 있습니다.\n### 2. 유지보수 용이성\n\n- 명확한 책임 분리: 각 컴포넌트와 Hook이 명확한 책임을 가지고 있어, 특정 기능에 대한 수정이 필요할 때 해당 파일만 수정하면 됩니다. 예를 들어, 데이터 Fetching 로직에 문제가 생겼다면 `useItemQuery`만 수정하면 되어, 전체 코드에 미치는 영향을 최소화할 수 있습니다.\n- 버그 수정의 용이성: 특정 기능에서 버그가 발생했을 경우, 해당 기능에 관련된 Hook이나 컴포넌트만 집중적으로 검토하고 수정하면 되므로 디버깅 과정이 단순해집니다.\n### 3. 가독성 및 이해도 향상\n\n- 명확한 코드 구조: 폴더 구조와 파일명이 기능에 맞춰 잘 정리되어 있어, 다른 개발자가 코드를 쉽게 이해하고 탐색할 수 있습니다. 새로운 팀원이 프로젝트에 참여할 때 빠르게 적응할 수 있는 환경을 제공합니다.\n- Documentation과 코드의 일관성: 각 Hook과 컴포넌트가 명확한 목적을 가지고 설계되어 있어, 코드가 자연스럽게 문서화된 형태가 됩니다. 이는 팀원 간의 소통을 원활하게 하고, 코드 리뷰 시 이해도를 높입니다.\n### 4. 상태 관리의 일관성\n\n- 전역 상태 관리와의 통합: RTK Query와 같은 라이브러리를 사용하여 상태를 관리함으로써, 데이터의 흐름을 일관되게 유지할 수 있습니다. 이로 인해 데이터 패칭 및 상태 업데이트가 명확해지며, 개발자가 데이터의 흐름을 쉽게 추적할 수 있습니다.\n- 캐시 및 Stale 데이터 관리: RTK Query의 Tag 기능을 통해 데이터의 신선도를 관리할 수 있어, 사용자가 항상 최신 정보를 받을 수 있도록 보장합니다. 이는 사용자 경험을 크게 향상시킵니다.\n### 5. 확장성 및 유연성\n\n- 기능 추가 용이: 새로운 기능이나 컴포넌트를 추가할 때 기존 구조를 그대로 활용할 수 있습니다. 필요에 따라 새로운 Hook을 추가하거나 기존 Hook을 수정하여 기능을 확장할 수 있습니다. 예를 들어, 새로운 API 엔드포인트가 추가되면, 새로운 Hook을 만들어 손쉽게 통합할 수 있습니다.\n- 다양한 사용 사례 지원: 각 컴포넌트가 독립적으로 설계되어 있어, 여러 상황에서 재사용이 가능합니다. 이는 코드 중복을 줄이고, 다양한 시나리오에 쉽게 적응할 수 있게 합니다.\n# 단점 설명\n\n---\n\n### 1. 초기 설정 및 러닝 커브\n\n- 복잡한 구조: 모듈화된 구조는 처음 프로젝트에 참여하는 개발자에게는 다소 복잡하게 느껴질 수 있습니다. 각 Hook과 컴포넌트가 분리되어 있어, 전체 흐름을 이해하는 데 시간이 걸릴 수 있습니다.\n- Hooks 사용법 이해 필요: Custom Hooks의 사용법과 구조를 이해해야 하므로, 초보 개발자나 팀원에게는 추가적인 학습 시간이 필요할 수 있습니다\n### 2. 과도한 추상화\n\n- 단순한 기능의 복잡성 증가: 간단한 기능을 구현할 때도 여러 Hook과 컴포넌트를 만들다 보면, 오히려 코드가 복잡해질 수 있습니다. 이로 인해 개발자가 불필요한 구조를 만들게 될 위험이 있다고 생각합니다.\n- 추상화의 남용: 지나치게 많은 추상화는 코드의 가독성을 떨어뜨리고, 실제로 필요한 기능을 찾기 어려워 지거나, 억지로 끼워 맞춰야 하는 상황이 생길 수 있다고 생각합니다.\n---\n\n이렇게 요즘 제가 고민하고 만들어가고 있는 컴포넌트 설계 방법을 소개해 드렸습니다. 긴 글을 읽어주셔서 감사합니다. 이 방법이 절대적인 정답은 아니라는 점도 잘 알고 있습니다. 앞으로도 계속해서 다양한 시도를 하고 새로운 방법을 찾아가는 개발자가 되겠습니다! 감사합니다.\n\n"
}