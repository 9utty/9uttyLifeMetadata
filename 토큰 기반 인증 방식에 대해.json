{
  "title": "토큰 기반 인증 방식에 대해",
  "createAt": "2024-10-10T11:15:00.000Z",
  "updateAt": "2024-10-10T11:17:00.000Z",
  "tags": "Web,Frontend,Auth",
  "content": "```yaml\ntitle: \"토큰 기반 인증 방식에 대해\"\ndescription: \"React의 Server Components는 서버에서 렌더링되어 초기 로딩 속도를 개선하고 SEO에 유리하나, 상태 관리와 유연성에서 복잡성이 증가할 수 있는 특징이 있다. 이를 통해 성능 최적화 방법과 함께 고려해야 할 점도 설명된다.\"\nogImage: \"https://opengraph.b-cdn.net/production/images/c75fa6d5-ce88-493d-89c1-57b7636d623c.png?token=ZQPb-u9y5Kec5UbWnfDtQMX6NHrbO3qZGAJEkjkWFj4&height=1200&width=1200&expires=33263845179\"\ncleanUrl: \"/fe-study/token\"\n```\n\n# 질문\n\n---\n\n토큰 기반 인증 방식에 대해 설명해주세요. 그리고 JWT 토큰을 쿠키에 저장했을 때 취약점에 대해 설명해주세요.\n\n# 질문의도\n\n---\n\nJWT에 대한 기본적인 이해와 함께, JWT를 쿠키에 저장할 때 발생할 수 있는 보안 취약점에 대한 인식을 평가하려는 목적입니다. 이를 통해 인증 및 보안 메커니즘에 대한 깊이 있는 지식과 보안 문제에 대한 인지 능력을 확인하려는 목적이 있습니다.\n\n\n\n# JWT의 설명\n\n### **1. 토큰 기반 인증 방식이 탄생한 계기**\n\n- 서버 부하 문제: 전통적인 세션 기반 인증에서는 사용자가 로그인할 때 서버가 해당 사용자의 세션 정보를 저장해야한다(State full). 하지만 사용자가 많아지면 서버의 부하가 많은 만큼 성능 저하가 발생할 수 있다는 단점이 존재했다.\n- 상태 비저장 통신 필요: RESTful API와 같은 현대적인 웹 애플리케이션에서는 클라이언트와 서버가 독립적으로 동작하는 것이 중요해졌다. 한마디로 상태를 몰라도 동작할 수 있어야한다(State less)이를 위해 클라이언트가 인증 정보를 포함하는 '토큰'을 사용하여 서버에 요청할 수 있게 만든게 토큰 기반 인증 방식이다.\n### **2. 토큰 인증 방식**\n\n- 로그인 후 토큰 생성: 사용자가 로그인하면 서버는 사용자의 인증 정보를 바탕으로 고유한 토큰을 생성하여 클라이언트에 반환한다.\n- 토큰으로 요청하기: 클라이언트는 이후 서버에 요청할 때 이 토큰을 `Authorization` 헤더에 담아 보낸다. 예를 들어, `Authorization: Bearer <토큰>` 형식으로 전송할 수 있다.\n- 서버에서 검증: 서버는 수신한 토큰이 서버가 발급한게 맞는지 유효기간은 충분한지 등 확인하고, 문제가 없다면 요청을 처리한다.\n### **3. JWT의 보안 방식**\n\n- JWT 구조: JWT는 `헤더`, `페이로드`, `서명` 구조로 만들어져 있다.\n- 만료 시간 설정: JWT는 만료 시간을 설정할 수 있어, 특정 시간이 지나면 사용할 수 없도록 설정할 수 있는데 이 부분은 보안을 강화하는 데 도움이 된다.\n### **4. 토큰 인증 방식과 JWT의 보안 방식의 차이점**\n\n- 일반 토큰의 취약성: 일반적인 토큰은 단순히 문자열일 수 있으며, 별도의 보안 조치가 없기 때문에 쉽게 변조될 수 있다. \n- JWT의 안전함: JWT는 서명된 구조로 되어 있어, 누군가 토큰을 변경하려고 하면 서명이 깨지므로 서버에서 이를 인식할 수 있다. 따라서 JWT는 더 안전한 인증 방법이라고 생각한다.\n### **5. 오늘날의 리프레쉬 토큰과 일반 엑세스 토큰 사용 방법**\n\n- 액세스 토큰: 이 토큰은 짧은 유효 기간을 가지고 있으며, API 요청 시 사용된다. 예를 들어, 15분 정도의 짧은 시간 동안만 유효하게 만들 수 있다.\n- 리프레쉬 토큰: 이 토큰은 긴 유효 기간을 가지며, 사용자가 액세스 토큰이 만료되었을 때 새로운 액세스 토큰을 발급받기 위해 사용된다. 보안상의 이유로, 리프레쉬 토큰은 서버에 안전하게 저장해야 한다.(이렇게 되면 사실상 State full)\n- 저장 위치: 액세스 토큰은 클라이언트의 메모리에 저장하여 API 요청 시 사용하고, 리프레쉬 토큰은 서버에서 안전하게 관리하여 클라이언트가 직접 접근하지 못하도록 한다.\n\n\n\n# 토큰을 쿠키에 저장했을 때 보안상 이슈\n\n### **1. XSS(교차 사이트 스크립팅) 공격**\n\n- **문제: 만약 웹 애플리케이션에 XSS 취약점이 있다면, 공격자가 악성 스크립트를 주입하여 사용자의 쿠키에 저장된 토큰을 탈취할 수 있다.**\n- **해결책: 쿠키에 **`**HttpOnly**`** 속성을 설정하여 자바스크립트에서 쿠키에 접근할 수 없도록 하고, XSS 방어를 위한 보안 코드를 작성해야 한다.**\n### **2. CSRF(교차 사이트 요청 위조) 공격**\n\n- **문제: 사용자가 인증된 상태에서 악의적인 사이트에 방문하게 되면, 해당 사이트가 사용자의 쿠키를 사용하여 요청을 보낼 수 있다.**\n- **해결책: CSRF 토큰을 사용하여 요청의 유효성을 검증하거나, **`**SameSite**`** 속성을 설정하여 쿠키가 다른 사이트에서 사용되지 않도록 해야 한다.**\n### **3. 쿠키 탈취**\n\n- **문제: 네트워크를 통해 쿠키가 전송될 때, 공격자가 이를 가로챌 수 있습니다. 특히 HTTP를 사용할 경우, 암호화되지 않은 상태로 전송되어 위험하다.**\n- **해결책: 쿠키에 **`**Secure**`** 속성을 설정하여 HTTPS를 통해서만 전송되도록 하고, 모든 통신을 HTTPS로 암호화해야 한다.(HTTPS 씁시다!)**\n### **4. 쿠키의 유효 기간**\n\n- **문제: 쿠키의 유효 기간이 길게 설정되면, 탈취된 쿠키를 통해 악의적인 사용자가 오랜 시간 동안 접근할 수 있는 위험이 있다.**\n- **해결책: 쿠키의 유효 기간을 짧게 설정하고, 필요시 리프레쉬 토큰을 사용하여 새로운 액세스 토큰을 발급받는 방식으로 관리하는게 좋다.**\n### **5. 정보 노출**\n\n- **문제: 쿠키에 민감한 정보를 직접 저장할 경우, 해당 정보가 유출될 위험이 있다.**\n- **해결책: 쿠키에는 최소한의 정보만 저장하고, 토큰 자체에 민감한 정보를 포함시키지 않도록 설계해야 한다.**\n"
}